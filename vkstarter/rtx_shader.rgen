#version 460
#extension GL_NVX_raytracing : require

// See: https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_ray_tracing.txt

layout(push_constant) uniform PushConstants 
{
    float time;
    float padding;
    vec2 resolution;
} push_constants;

layout(set = 0, binding = 0) uniform accelerationStructureNVX acceleration_structure;
layout(set = 0, binding = 1, rgba8) uniform image2D result_image;

// The ray payload object is an application-defined struct used to pass 
// data between hit stages and the shader stage that spawned a ray
layout(location = 0) rayPayloadNVX vec3 result_color;

const vec3 camera_right = { 1.0, 0.0, 0.0 };
const vec3 camera_up = { 0.0, 1.0, 0.0 };
const vec3 camera_forward = { 0.0, 0.0, 1.0 };
const float fov = 45.0;
const vec3 camera_position = { 0.0, 0.0, -5.0 };

vec3 find_ray_direction(in vec2 screen_uv, float aspect_ratio) 
{
    vec3 u = camera_right;
    vec3 v = camera_up;

    const float plane_width = tan(fov * 0.5);
    u *= (plane_width * aspect_ratio);
    v *= plane_width;

    return normalize(camera_forward + (u * screen_uv.x) - (v * screen_uv.y));
}


void main() 
{
    // Generate UV-coordinates in the range [-1..1] and flip y-axis
    vec2 uv = vec2(gl_LaunchIDNVX.xy) / vec2(gl_LaunchSizeNVX.xy - 1);
    uv.y = 1.0 - uv.y;
    uv = uv * 2.0 - 1.0;

    const float aspect_ratio = push_constants.resolution.x / push_constants.resolution.y;
    vec3 ray_direction = find_ray_direction(uv, aspect_ratio); 
    vec3 ray_origin = camera_position;

    const uint ray_flags = gl_RayFlagsNoneNVX;
    const uint cull_mask = 0xFF;

    // Index and size of the intersection group in our SBT
    const uint shader_binding_table_record_offset = 0;
    const uint shader_binding_table_record_stride = 0;

    // Index of miss shader group
    const uint miss_index = 0;
    const float tmin = 0.0f;
    const float tmax = 10.0f;
    const int payload_location = 0;

    traceNVX(acceleration_structure,
             ray_flags,
             cull_mask,
             shader_binding_table_record_offset,
             shader_binding_table_record_stride,
             miss_index,
             ray_origin,
             tmin,
             ray_direction,
             tmax,
             payload_location);

    imageStore(result_image, ivec2(gl_LaunchIDNVX.xy), vec4(result_color, 1.0f));
}
